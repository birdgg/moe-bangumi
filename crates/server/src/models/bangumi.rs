use serde::{Deserialize, Serialize};
use std::str::FromStr;
#[cfg(feature = "openapi")]
use utoipa::ToSchema;

use super::{CreateMetadata, Metadata};

/// Source type for bangumi
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Serialize, Deserialize)]
#[cfg_attr(feature = "openapi", derive(ToSchema))]
#[serde(rename_all = "lowercase")]
pub enum SourceType {
    #[default]
    WebRip,
    BDRip,
}

impl SourceType {
    pub fn as_str(&self) -> &'static str {
        match self {
            SourceType::WebRip => "webrip",
            SourceType::BDRip => "bdrip",
        }
    }
}

impl FromStr for SourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(match s.to_lowercase().as_str() {
            "bdrip" => SourceType::BDRip,
            _ => SourceType::WebRip,
        })
    }
}

/// Bangumi (anime) subscription entity
/// Stores user's subscription state and download configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "openapi", derive(ToSchema))]
pub struct Bangumi {
    pub id: i64,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,

    /// Reference to metadata (foreign key)
    pub metadata_id: i64,

    /// Episode offset
    pub episode_offset: i32,

    /// Current downloaded episode
    pub current_episode: i32,
    /// Only download first matching episode per RSS check
    pub auto_complete: bool,

    /// Save path (required)
    pub save_path: String,

    /// Source type: webrip or bdrip
    pub source_type: SourceType,
}

impl Bangumi {
    /// Convert RSS episode number to season-relative episode number.
    ///
    /// RSS feeds typically use absolute episode numbers (e.g., episode 13 for a split-cour anime),
    /// but media servers expect season-relative numbers (e.g., S02E01).
    ///
    /// The offset is calculated as `sort - ep` from BGM.tv episode data.
    #[inline]
    pub fn adjust_episode(&self, episode: i32) -> i32 {
        episode - self.episode_offset
    }
}

/// Bangumi with its associated metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "openapi", derive(ToSchema))]
pub struct BangumiWithMetadata {
    #[serde(flatten)]
    pub bangumi: Bangumi,
    /// Associated metadata
    pub metadata: Metadata,
}

/// RSS entry for creating bangumi with subscriptions
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "openapi", derive(ToSchema))]
pub struct RssEntry {
    /// RSS feed URL
    pub url: String,
    /// Regex patterns to exclude from matching
    #[serde(default)]
    pub filters: Vec<String>,
    /// Regex patterns to include in matching
    #[serde(default)]
    pub include_filters: Vec<String>,
    /// Optional subtitle group name
    #[serde(default)]
    pub subtitle_group: Option<String>,
}

/// Request body for creating a new bangumi
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "openapi", derive(ToSchema))]
pub struct CreateBangumi {
    /// Metadata ID (if using existing metadata)
    pub metadata_id: Option<i64>,
    /// Inline metadata creation (if not using existing)
    pub metadata: Option<CreateMetadata>,

    /// Episode offset
    #[serde(default)]
    pub episode_offset: i32,
    /// Only download first matching episode per RSS check
    #[serde(default = "default_auto_complete")]
    pub auto_complete: bool,
    /// Source type
    #[serde(default)]
    pub source_type: SourceType,

    /// RSS subscriptions to create with this bangumi
    #[serde(default)]
    pub rss_entries: Vec<RssEntry>,

    /// Save path (auto-generated by backend, not exposed in API)
    #[serde(skip_deserializing, default)]
    #[cfg_attr(feature = "openapi", schema(read_only))]
    pub save_path: String,
}

fn default_auto_complete() -> bool {
    true
}

/// Bangumi with metadata and RSS subscriptions
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "openapi", derive(ToSchema))]
pub struct BangumiWithRss {
    #[serde(flatten)]
    pub bangumi: Bangumi,
    /// Associated metadata
    pub metadata: Metadata,
    /// RSS subscriptions for this bangumi
    pub rss_entries: Vec<super::Rss>,
}

/// Request body for updating a bangumi with RSS entries
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "openapi", derive(ToSchema))]
pub struct UpdateBangumiRequest {
    /// Episode offset
    pub episode_offset: Option<i32>,
    /// Only download first matching episode per RSS check
    pub auto_complete: Option<bool>,
    /// RSS entries to sync (replaces all existing entries)
    pub rss_entries: Option<Vec<RssEntry>>,
}

/// Request body for updating a bangumi.
/// Only contains subscription-related fields (metadata updates use UpdateMetadata)
#[derive(Debug, Clone, Default, Deserialize)]
pub struct UpdateBangumi {
    #[serde(default)]
    pub episode_offset: Option<i32>,
    #[serde(default)]
    pub current_episode: Option<i32>,
    #[serde(default)]
    pub auto_complete: Option<bool>,
    #[serde(default)]
    pub source_type: Option<SourceType>,
}
