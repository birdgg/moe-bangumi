// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
  baseUrl: "http://127.0.0.1:3000" | (string & {});
};

/**
 * Bangumi (anime) main entity
 */
export type Bangumi = {
  /**
   * First air date (YYYY-MM-DD format, required)
   */
  air_date: string;
  /**
   * Day of week when new episodes air (0=Sunday, 1=Monday, ..., 6=Saturday, required)
   */
  air_week: number;
  /**
   * Only download the latest episode
   */
  auto_complete: boolean;
  /**
   * Bangumi.tv ID
   */
  bgmtv_id?: number | null;
  created_at: string;
  /**
   * Current downloaded episode
   */
  current_episode: number;
  /**
   * Episode offset
   */
  episode_offset: number;
  /**
   * Whether the bangumi has finished airing
   */
  finished: boolean;
  id: number;
  /**
   * Platform type (TV, Movie, OVA)
   */
  platform: Platform;
  /**
   * Poster URL
   */
  poster_url?: string | null;
  /**
   * Save path (required)
   */
  save_path: string;
  /**
   * Season number
   */
  season: number;
  /**
   * Source type: webrip or bdrip
   */
  source_type: SourceType;
  /**
   * Chinese title (primary display)
   */
  title_chinese: string;
  /**
   * Japanese original name
   */
  title_japanese?: string | null;
  /**
   * Original Chinese title (native language, required, unique)
   */
  title_original_chinese: string;
  /**
   * Original Japanese title
   */
  title_original_japanese?: string | null;
  /**
   * TMDB ID
   */
  tmdb_id?: number | null;
  /**
   * Total episodes (0=unknown)
   */
  total_episodes: number;
  updated_at: string;
  /**
   * Year
   */
  year: number;
};

export type BangumiDetail = {
  subgroups: Array<Subgroup>;
};

/**
 * Bangumi with its RSS subscriptions
 */
export type BangumiWithRss = Bangumi & {
  /**
   * RSS subscriptions for this bangumi
   */
  rss_entries: Array<Rss>;
};

/**
 * Collection information for calendar subject
 */
export type CalendarCollection = {
  doing?: number;
};

/**
 * Calendar day with weekday info and items
 */
export type CalendarDay = {
  items: Array<CalendarSubject>;
  weekday: Weekday;
};

/**
 * Rating information for calendar subject
 */
export type CalendarRating = {
  score: number;
  total: number;
};

/**
 * Subject item in calendar results
 */
export type CalendarSubject = {
  air_date: string;
  air_weekday: number;
  collection?: null | CalendarCollection;
  id: number;
  images: SubjectImages;
  name: string;
  name_cn: string;
  rank?: number | null;
  rating?: null | CalendarRating;
  summary?: string;
  type: SubjectType;
};

/**
 * Request body for creating a new bangumi
 */
export type CreateBangumi = {
  /**
   * First air date (YYYY-MM-DD format, required)
   */
  air_date: string;
  /**
   * Day of week when new episodes air (0=Sunday, 1=Monday, ..., 6=Saturday, required)
   */
  air_week: number;
  /**
   * Only download first matching episode per RSS check
   */
  auto_complete?: boolean;
  /**
   * Bangumi.tv ID
   */
  bgmtv_id?: number | null;
  /**
   * Episode offset
   */
  episode_offset?: number;
  /**
   * Whether the bangumi has finished airing
   */
  finished?: boolean;
  /**
   * Platform type (TV, Movie, OVA)
   */
  platform?: Platform;
  /**
   * Poster URL
   */
  poster_url?: string | null;
  /**
   * RSS subscriptions to create with this bangumi
   */
  rss_entries?: Array<RssEntry>;
  /**
   * Season number (default: 1)
   */
  season?: number;
  /**
   * Source type
   */
  source_type?: SourceType;
  /**
   * Chinese title (required)
   */
  title_chinese: string;
  /**
   * Japanese original name
   */
  title_japanese?: string | null;
  /**
   * Original Chinese title (native language, required, unique)
   */
  title_original_chinese: string;
  /**
   * Original Japanese title
   */
  title_original_japanese?: string | null;
  /**
   * TMDB ID
   */
  tmdb_id?: number | null;
  /**
   * Total episodes
   */
  total_episodes?: number;
  /**
   * Year (required)
   */
  year: number;
};

/**
 * Request to delete torrents
 */
export type DeleteTorrentsRequest = {
  /**
   * Whether to delete downloaded files (default: true)
   */
  delete_files?: boolean;
  /**
   * List of torrent hashes
   */
  hashes: Array<string>;
};

/**
 * Per-downloader configurations
 */
export type DownloaderConfigs = {
  /**
   * qBittorrent configuration
   */
  qbittorrent?: QBittorrentConfig;
  /**
   * Transmission configuration
   */
  transmission?: TransmissionConfig;
};

/**
 * Downloader configuration with per-type configs
 */
export type DownloaderSettings = {
  /**
   * Per-downloader configurations
   */
  configs?: DownloaderConfigs;
  /**
   * Default save path for downloads (shared across all downloaders)
   */
  save_path?: string;
  /**
   * Currently active downloader type
   */
  type?: DownloaderType;
};

/**
 * Downloader type
 */
export type DownloaderType = "qBittorrent" | "Transmission";

/**
 * Episode item
 */
export type Episode = {
  /**
   * Air date
   */
  airdate: string;
  /**
   * Episode number
   */
  ep?: number | null;
  id: number;
  /**
   * Original name
   */
  name: string;
  /**
   * Chinese name
   */
  name_cn: string;
  /**
   * Sort order
   */
  sort: number;
  /**
   * Episode type: 0=本篇, 1=SP, 2=OP, 3=ED
   */
  type: EpisodeType;
};

/**
 * Episode type
 */
export type EpisodeType = "Main" | "Special" | "Opening" | "Ending";

/**
 * Filter configuration
 */
export type FilterSettings = {
  /**
   * Global RSS filters (regex patterns to exclude)
   */
  global_rss_filters?: Array<string>;
};

/**
 * System log entity
 */
export type Log = {
  created_at: string;
  id: number;
  /**
   * 日志级别: info, warning, error
   */
  level: LogLevel;
  /**
   * 日志消息
   */
  message: string;
};

/**
 * Log severity level
 */
export type LogLevel = "info" | "warning" | "error";

/**
 * Notification configuration
 */
export type NotificationSettings = {
  /**
   * Global enable/disable for notifications
   */
  enabled?: boolean;
  /**
   * Telegram configuration
   */
  telegram?: TelegramConfig;
};

/**
 * Platform type for bangumi (TV, Movie, OVA)
 */
export type Platform = "tv" | "movie" | "ova";

/**
 * Proxy configuration for HTTP client
 */
export type ProxySettings = {
  /**
   * Proxy password (optional)
   */
  password?: string;
  /**
   * Proxy server URL (e.g., http://127.0.0.1:7890 or socks5://127.0.0.1:1080)
   */
  url?: string;
  /**
   * Proxy username (optional)
   */
  username?: string;
};

/**
 * qBittorrent-specific configuration
 */
export type QBittorrentConfig = {
  /**
   * Password (required)
   */
  password?: string;
  /**
   * Web UI URL (e.g., http://localhost:8080)
   */
  url?: string;
  /**
   * Username (required)
   */
  username?: string;
};

/**
 * RSS subscription entity
 */
export type Rss = {
  /**
   * Foreign key to bangumi
   */
  bangumi_id: number;
  created_at: string;
  /**
   * Whether subscription is enabled
   */
  enabled: boolean;
  /**
   * Regex patterns to exclude from matching
   */
  exclude_filters: Array<string>;
  /**
   * Optional subtitle group name
   */
  group?: string | null;
  id: number;
  /**
   * Regex patterns to include (AND logic - title must match ALL patterns if not empty)
   */
  include_filters: Array<string>;
  /**
   * Whether this is the primary RSS source (only one per bangumi)
   * Episodes from primary RSS can override those from backup RSS
   */
  is_primary: boolean;
  /**
   * RSS subscription title: [group] {bangumi} S{season}
   */
  title: string;
  updated_at: string;
  /**
   * RSS feed URL
   */
  url: string;
};

/**
 * RSS entry for creating bangumi with subscriptions
 */
export type RssEntry = {
  /**
   * Regex patterns to exclude from matching
   */
  filters?: Array<string>;
  /**
   * Optional subtitle group name
   */
  group?: string | null;
  /**
   * Regex patterns to include (AND logic)
   */
  include_filters?: Array<string>;
  /**
   * Whether this is the primary RSS source (default: false)
   */
  is_primary?: boolean;
  /**
   * RSS feed URL
   */
  url: string;
};

export type SearchResult = {
  id: string;
  name: string;
};

/**
 * Search response from POST /v0/search/subjects
 */
export type SearchSubjectsResponse = {
  data: Array<Subject>;
  limit: number;
  offset: number;
  total: number;
};

/**
 * Application settings stored in TOML file
 */
export type Settings = {
  /**
   * Downloader configuration
   */
  downloader?: DownloaderSettings;
  /**
   * Filter configuration
   */
  filter?: FilterSettings;
  /**
   * Notification configuration
   */
  notification?: NotificationSettings;
  /**
   * Proxy configuration for HTTP client
   */
  proxy?: ProxySettings;
};

/**
 * Source type for bangumi
 */
export type SourceType = "webrip" | "bdrip";

export type Subgroup = {
  episodes: Array<Episode>;
  id: string;
  name: string;
  rss_url: string;
};

/**
 * Subject item in search results
 */
export type Subject = {
  date: string;
  eps: number;
  id: number;
  image: string;
  images: SubjectImages;
  name: string;
  name_cn: string;
  platform: string;
};

/**
 * Subject images from BGM.tv API
 */
export type SubjectImages = {
  common: string;
  grid: string;
  large: string;
  medium: string;
  small: string;
};

/**
 * BGM.tv subject type
 */
export type SubjectType = "Book" | "Anime" | "Music" | "Game" | "Real";

/**
 * Unified download task representation.
 *
 * This model represents a download task across different downloaders,
 * normalizing fields into a common structure.
 */
export type Task = {
  /**
   * Category (optional, some downloaders support this)
   */
  category?: string | null;
  /**
   * Downloaded bytes
   */
  downloaded: number;
  /**
   * Estimated time to completion (seconds, -1 if unknown)
   */
  eta: number;
  /**
   * Unique identifier (hash for BitTorrent, ID for HTTP)
   */
  id: string;
  /**
   * Task name
   */
  name: string;
  /**
   * Download progress (0.0 to 1.0)
   */
  progress: number;
  /**
   * Save path / download directory
   */
  save_path: string;
  /**
   * Current status
   */
  status: TaskStatus;
  /**
   * Tags (comma-separated string for consistency)
   */
  tags: string;
  /**
   * Total size in bytes
   */
  total_size: number;
};

/**
 * Download task status.
 *
 * Normalized across different downloader implementations.
 */
export type TaskStatus =
  | "queued"
  | "downloading"
  | "paused"
  | "seeding"
  | "completed"
  | "stalled"
  | "checking"
  | "error"
  | "unknown";

/**
 * Telegram notification configuration
 */
export type TelegramConfig = {
  /**
   * Telegram Bot API token
   */
  bot_token?: string;
  /**
   * Telegram chat ID to send notifications to
   */
  chat_id?: string;
  /**
   * Enable Telegram notifications
   */
  enabled?: boolean;
};

/**
 * Request body for testing downloader connection
 */
export type TestDownloaderRequest = {
  /**
   * Password
   */
  password: string;
  /**
   * Downloader type (e.g., "qbittorrent")
   */
  type: DownloaderType;
  /**
   * Downloader Web UI URL
   */
  url: string;
  /**
   * Username
   */
  username: string;
};

/**
 * Request body for testing Telegram notification
 */
export type TestNotificationRequest = {
  /**
   * Telegram Bot API token
   */
  bot_token: string;
  /**
   * Telegram chat ID
   */
  chat_id: string;
};

/**
 * Request body for testing proxy connection
 */
export type TestProxyRequest = {
  /**
   * Proxy password (optional)
   */
  password?: string | null;
  /**
   * Proxy server URL (e.g., http://127.0.0.1:7890)
   */
  url: string;
  /**
   * Proxy username (optional)
   */
  username?: string | null;
};

export type TorrentSearchResult = {
  info_hash: string;
  source: TorrentSource;
  title: string;
  torrent_url: string;
};

export type TorrentSource = "mikan" | "nyaa";

/**
 * Transmission-specific configuration
 */
export type TransmissionConfig = {
  /**
   * Password (optional)
   */
  password?: string;
  /**
   * RPC URL (e.g., http://localhost:9091/transmission/rpc)
   */
  url?: string;
  /**
   * Username (optional)
   */
  username?: string;
};

export type TvShow = {
  backdrop_path?: string | null;
  first_air_date?: string | null;
  genre_ids: Array<number>;
  id: number;
  name: string;
  origin_country: Array<string>;
  original_language: string;
  original_name: string;
  overview: string;
  popularity: number;
  poster_path?: string | null;
  vote_average: number;
  vote_count: number;
};

/**
 * Request body for updating a bangumi with RSS entries
 */
export type UpdateBangumiRequest = {
  /**
   * First air date (None = unchanged, Some = new value)
   */
  air_date?: string | null;
  /**
   * Day of week when new episodes air (None = unchanged, Some = new value)
   */
  air_week?: number | null;
  /**
   * Only download first matching episode per RSS check
   */
  auto_complete?: boolean | null;
  /**
   * Episode offset
   */
  episode_offset?: number | null;
  /**
   * RSS entries to sync (replaces all existing entries)
   */
  rss_entries?: Array<RssEntry> | null;
};

/**
 * Request body for updating downloader settings
 */
export type UpdateDownloaderSettings = {
  qbittorrent?: null | UpdateQBittorrentConfig;
  /**
   * Update shared save path (send null to clear)
   */
  save_path?: string | null;
  transmission?: null | UpdateTransmissionConfig;
  type?: null | DownloaderType;
};

/**
 * Request body for updating filter settings
 */
export type UpdateFilterSettings = {
  /**
   * Global RSS filters (replaces entire array if provided)
   */
  global_rss_filters?: Array<string> | null;
};

/**
 * Request body for updating notification settings
 */
export type UpdateNotificationSettings = {
  /**
   * Enable/disable notifications globally
   */
  enabled?: boolean | null;
  telegram?: null | UpdateTelegramConfig;
};

/**
 * Request body for updating proxy settings
 */
export type UpdateProxySettings = {
  /**
   * Password (send null to clear)
   */
  password?: string | null;
  /**
   * Proxy server URL (send null to clear)
   */
  url?: string | null;
  /**
   * Username (send null to clear)
   */
  username?: string | null;
};

/**
 * Request body for updating qBittorrent settings
 */
export type UpdateQBittorrentConfig = {
  /**
   * Password (send null to clear)
   */
  password?: string | null;
  /**
   * Web UI URL (send null to clear)
   */
  url?: string | null;
  /**
   * Username (send null to clear)
   */
  username?: string | null;
};

/**
 * Request body for updating settings.
 * All fields are optional - only provided fields will be updated.
 */
export type UpdateSettings = {
  downloader?: null | UpdateDownloaderSettings;
  filter?: null | UpdateFilterSettings;
  notification?: null | UpdateNotificationSettings;
  proxy?: null | UpdateProxySettings;
};

/**
 * Request body for updating Telegram settings
 */
export type UpdateTelegramConfig = {
  /**
   * Bot token (send null to clear)
   */
  bot_token?: string | null;
  /**
   * Chat ID (send null to clear)
   */
  chat_id?: string | null;
  /**
   * Enable Telegram notifications
   */
  enabled?: boolean | null;
};

/**
 * Request body for updating Transmission settings
 */
export type UpdateTransmissionConfig = {
  /**
   * Password (send null to clear)
   */
  password?: string | null;
  /**
   * RPC URL (send null to clear)
   */
  url?: string | null;
  /**
   * Username (send null to clear)
   */
  username?: string | null;
};

/**
 * Weekday information for calendar
 */
export type Weekday = {
  cn: string;
  en: string;
  id: number;
  ja: string;
};

export type GetBangumiData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/api/bangumi";
};

export type GetBangumiResponses = {
  /**
   * List of all bangumi
   */
  200: Array<Bangumi>;
};

export type GetBangumiResponse = GetBangumiResponses[keyof GetBangumiResponses];

export type CreateBangumiData = {
  body: CreateBangumi;
  path?: never;
  query?: never;
  url: "/api/bangumi";
};

export type CreateBangumiResponses = {
  /**
   * Bangumi created successfully
   */
  201: Bangumi;
};

export type CreateBangumiResponse =
  CreateBangumiResponses[keyof CreateBangumiResponses];

export type GetBangumiByIdData = {
  body?: never;
  path: {
    /**
     * Bangumi ID
     */
    id: number;
  };
  query?: never;
  url: "/api/bangumi/{id}";
};

export type GetBangumiByIdErrors = {
  /**
   * Bangumi not found
   */
  404: unknown;
};

export type GetBangumiByIdResponses = {
  /**
   * Bangumi with RSS subscriptions
   */
  200: BangumiWithRss;
};

export type GetBangumiByIdResponse =
  GetBangumiByIdResponses[keyof GetBangumiByIdResponses];

export type UpdateBangumiData = {
  body: UpdateBangumiRequest;
  path: {
    /**
     * Bangumi ID
     */
    id: number;
  };
  query?: never;
  url: "/api/bangumi/{id}";
};

export type UpdateBangumiErrors = {
  /**
   * Bangumi not found
   */
  404: unknown;
};

export type UpdateBangumiResponses = {
  /**
   * Bangumi updated successfully
   */
  200: BangumiWithRss;
};

export type UpdateBangumiResponse =
  UpdateBangumiResponses[keyof UpdateBangumiResponses];

export type GetCalendarData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/api/calendar";
};

export type GetCalendarResponses = {
  /**
   * Weekly anime schedule
   */
  200: Array<CalendarDay>;
};

export type GetCalendarResponse =
  GetCalendarResponses[keyof GetCalendarResponses];

export type TestDownloaderConnectionData = {
  body: TestDownloaderRequest;
  path?: never;
  query?: never;
  url: "/api/downloader/test";
};

export type TestDownloaderConnectionErrors = {
  /**
   * Authentication failed
   */
  401: unknown;
};

export type TestDownloaderConnectionResponses = {
  /**
   * Connection successful
   */
  200: unknown;
};

export type GetEpisodesData = {
  body?: never;
  path: {
    /**
     * BGM.tv subject ID
     */
    subject_id: number;
  };
  query?: never;
  url: "/api/episodes/{subject_id}";
};

export type GetEpisodesResponses = {
  /**
   * Episodes list
   */
  200: Array<Episode>;
};

export type GetEpisodesResponse =
  GetEpisodesResponses[keyof GetEpisodesResponses];

export type CleanupLogsData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/api/logs";
};

export type CleanupLogsResponses = {
  /**
   * Old logs deleted
   */
  200: number;
};

export type CleanupLogsResponse =
  CleanupLogsResponses[keyof CleanupLogsResponses];

export type GetLogsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filter by log level
     */
    level?: string | null;
    /**
     * Maximum number of logs to return (default: 50, max: 500)
     */
    limit?: number | null;
    /**
     * Number of logs to skip (for pagination)
     */
    offset?: number | null;
  };
  url: "/api/logs";
};

export type GetLogsResponses = {
  /**
   * Logs retrieved successfully
   */
  200: Array<Log>;
};

export type GetLogsResponse = GetLogsResponses[keyof GetLogsResponses];

export type StreamLogsData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/api/logs/stream";
};

export type StreamLogsResponses = {
  /**
   * SSE log stream
   */
  200: unknown;
};

export type GetMikanRssData = {
  body?: never;
  path?: never;
  query: {
    /**
     * ID to lookup
     */
    id: string;
  };
  url: "/api/mikan/rss";
};

export type GetMikanRssResponses = {
  /**
   * Bangumi detail with subgroups and RSS URLs
   */
  200: BangumiDetail;
};

export type GetMikanRssResponse =
  GetMikanRssResponses[keyof GetMikanRssResponses];

export type TestNotificationData = {
  body: TestNotificationRequest;
  path?: never;
  query?: never;
  url: "/api/notification/test";
};

export type TestNotificationErrors = {
  /**
   * Invalid configuration
   */
  400: unknown;
};

export type TestNotificationResponses = {
  /**
   * Notification sent successfully
   */
  200: unknown;
};

export type TestProxyData = {
  body: TestProxyRequest;
  path?: never;
  query?: never;
  url: "/api/proxy/test";
};

export type TestProxyErrors = {
  /**
   * Invalid proxy configuration
   */
  400: unknown;
};

export type TestProxyResponses = {
  /**
   * Proxy connection successful
   */
  200: unknown;
};

export type SearchBgmtvData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Keyword to search
     */
    keyword: string;
  };
  url: "/api/search/bgmtv";
};

export type SearchBgmtvResponses = {
  /**
   * Search results
   */
  200: Array<Subject>;
};

export type SearchBgmtvResponse =
  SearchBgmtvResponses[keyof SearchBgmtvResponses];

export type SearchMikanData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Keyword to search
     */
    keyword: string;
  };
  url: "/api/search/mikan";
};

export type SearchMikanResponses = {
  /**
   * Search results from Mikan
   */
  200: Array<SearchResult>;
};

export type SearchMikanResponse =
  SearchMikanResponses[keyof SearchMikanResponses];

export type SearchTmdbData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Keyword to search
     */
    keyword: string;
  };
  url: "/api/search/tmdb";
};

export type SearchTmdbResponses = {
  /**
   * Search results from TMDB
   */
  200: Array<TvShow>;
};

export type SearchTmdbResponse = SearchTmdbResponses[keyof SearchTmdbResponses];

export type GetSettingsData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/api/settings";
};

export type GetSettingsResponses = {
  /**
   * Application settings
   */
  200: Settings;
};

export type GetSettingsResponse =
  GetSettingsResponses[keyof GetSettingsResponses];

export type UpdateSettingsData = {
  body: UpdateSettings;
  path?: never;
  query?: never;
  url: "/api/settings";
};

export type UpdateSettingsResponses = {
  /**
   * Settings updated successfully
   */
  200: Settings;
};

export type UpdateSettingsResponse =
  UpdateSettingsResponses[keyof UpdateSettingsResponses];

export type ResetSettingsData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/api/settings/reset";
};

export type ResetSettingsResponses = {
  /**
   * Settings reset successfully
   */
  200: Settings;
};

export type ResetSettingsResponse =
  ResetSettingsResponses[keyof ResetSettingsResponses];

export type ListTorrentsData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/api/torrents";
};

export type ListTorrentsErrors = {
  /**
   * Downloader not configured
   */
  400: unknown;
};

export type ListTorrentsResponses = {
  /**
   * List of all torrents
   */
  200: Array<Task>;
};

export type ListTorrentsResponse =
  ListTorrentsResponses[keyof ListTorrentsResponses];

export type DeleteTorrentsData = {
  body: DeleteTorrentsRequest;
  path?: never;
  query?: never;
  url: "/api/torrents/delete";
};

export type DeleteTorrentsErrors = {
  /**
   * Invalid request (empty hashes) or downloader not configured
   */
  400: unknown;
};

export type DeleteTorrentsResponses = {
  /**
   * Torrents deleted successfully
   */
  200: unknown;
};

export type SearchTorrentsData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Keyword to search
     */
    keyword: string;
    /**
     * Source to search from: "nyaa" (default) or "mikan"
     */
    source?: TorrentSource;
  };
  url: "/api/torrents/search";
};

export type SearchTorrentsResponses = {
  /**
   * Search results from the specified source
   */
  200: Array<TorrentSearchResult>;
};

export type SearchTorrentsResponse =
  SearchTorrentsResponses[keyof SearchTorrentsResponses];
