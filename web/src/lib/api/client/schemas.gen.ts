// This file is auto-generated by @hey-api/openapi-ts

export const BangumiSchema = {
  type: "object",
  description: "Bangumi (anime) main entity",
  required: [
    "id",
    "created_at",
    "updated_at",
    "title_chinese",
    "title_original_chinese",
    "season",
    "year",
    "air_date",
    "air_week",
    "total_episodes",
    "episode_offset",
    "current_episode",
    "auto_download",
    "save_path",
    "source_type",
    "finished",
    "platform",
  ],
  properties: {
    air_date: {
      type: "string",
      description: "First air date (YYYY-MM-DD format, required)",
    },
    air_week: {
      type: "integer",
      format: "int32",
      description:
        "Day of week when new episodes air (0=Sunday, 1=Monday, ..., 6=Saturday, required)",
    },
    auto_download: {
      type: "boolean",
      description: "Auto download new episodes",
    },
    bgmtv_id: {
      type: ["integer", "null"],
      format: "int64",
      description: "Bangumi.tv ID",
    },
    created_at: {
      type: "string",
      format: "date-time",
    },
    current_episode: {
      type: "integer",
      format: "int32",
      description: "Current downloaded episode",
    },
    episode_offset: {
      type: "integer",
      format: "int32",
      description: "Episode offset",
    },
    finished: {
      type: "boolean",
      description: "Whether the bangumi has finished airing",
    },
    id: {
      type: "integer",
      format: "int64",
    },
    platform: {
      $ref: "#/components/schemas/Platform",
      description: "Platform type (TV, Movie, OVA)",
    },
    poster_url: {
      type: ["string", "null"],
      description: "Poster URL",
    },
    save_path: {
      type: "string",
      description: "Save path (required)",
    },
    season: {
      type: "integer",
      format: "int32",
      description: "Season number",
    },
    source_type: {
      $ref: "#/components/schemas/SourceType",
      description: "Source type: webrip or bdrip",
    },
    title_chinese: {
      type: "string",
      description: "Chinese title (primary display)",
    },
    title_japanese: {
      type: ["string", "null"],
      description: "Japanese original name",
    },
    title_original_chinese: {
      type: "string",
      description: "Original Chinese title (native language, required, unique)",
    },
    title_original_japanese: {
      type: ["string", "null"],
      description: "Original Japanese title",
    },
    tmdb_id: {
      type: ["integer", "null"],
      format: "int64",
      description: "TMDB ID",
    },
    total_episodes: {
      type: "integer",
      format: "int32",
      description: "Total episodes (0=unknown)",
    },
    updated_at: {
      type: "string",
      format: "date-time",
    },
    year: {
      type: "integer",
      format: "int32",
      description: "Year",
    },
  },
} as const;

export const BangumiDetailSchema = {
  type: "object",
  required: ["subgroups"],
  properties: {
    subgroups: {
      type: "array",
      items: {
        $ref: "#/components/schemas/Subgroup",
      },
    },
  },
} as const;

export const BangumiWithRssSchema = {
  allOf: [
    {
      $ref: "#/components/schemas/Bangumi",
    },
    {
      type: "object",
      required: ["rss_entries"],
      properties: {
        rss_entries: {
          type: "array",
          items: {
            $ref: "#/components/schemas/Rss",
          },
          description: "RSS subscriptions for this bangumi",
        },
      },
    },
  ],
  description: "Bangumi with its RSS subscriptions",
} as const;

export const ControlTorrentsRequestSchema = {
  type: "object",
  description: "Request to control torrents (pause/resume)",
  required: ["hashes"],
  properties: {
    hashes: {
      type: "array",
      items: {
        type: "string",
      },
      description: "List of torrent hashes",
    },
  },
} as const;

export const CreateBangumiSchema = {
  type: "object",
  description: "Request body for creating a new bangumi",
  required: [
    "title_chinese",
    "title_original_chinese",
    "year",
    "air_date",
    "air_week",
    "save_path",
  ],
  properties: {
    air_date: {
      type: "string",
      description: "First air date (YYYY-MM-DD format, required)",
    },
    air_week: {
      type: "integer",
      format: "int32",
      description:
        "Day of week when new episodes air (0=Sunday, 1=Monday, ..., 6=Saturday, required)",
    },
    auto_download: {
      type: "boolean",
      description: "Auto download new episodes",
    },
    bgmtv_id: {
      type: ["integer", "null"],
      format: "int64",
      description: "Bangumi.tv ID",
    },
    episode_offset: {
      type: "integer",
      format: "int32",
      description: "Episode offset",
    },
    finished: {
      type: "boolean",
      description: "Whether the bangumi has finished airing",
    },
    platform: {
      $ref: "#/components/schemas/Platform",
      description: "Platform type (TV, Movie, OVA)",
    },
    poster_url: {
      type: ["string", "null"],
      description: "Poster URL",
    },
    rss_entries: {
      type: "array",
      items: {
        $ref: "#/components/schemas/RssEntry",
      },
      description: "RSS subscriptions to create with this bangumi",
    },
    save_path: {
      type: "string",
      description: "Save path (required)",
    },
    season: {
      type: "integer",
      format: "int32",
      description: "Season number (default: 1)",
    },
    source_type: {
      $ref: "#/components/schemas/SourceType",
      description: "Source type",
    },
    title_chinese: {
      type: "string",
      description: "Chinese title (required)",
    },
    title_japanese: {
      type: ["string", "null"],
      description: "Japanese original name",
    },
    title_original_chinese: {
      type: "string",
      description: "Original Chinese title (native language, required, unique)",
    },
    title_original_japanese: {
      type: ["string", "null"],
      description: "Original Japanese title",
    },
    tmdb_id: {
      type: ["integer", "null"],
      format: "int64",
      description: "TMDB ID",
    },
    total_episodes: {
      type: "integer",
      format: "int32",
      description: "Total episodes",
    },
    year: {
      type: "integer",
      format: "int32",
      description: "Year (required)",
    },
  },
} as const;

export const DeleteTorrentsRequestSchema = {
  type: "object",
  description: "Request to delete torrents",
  required: ["hashes"],
  properties: {
    delete_files: {
      type: "boolean",
      description: "Whether to delete downloaded files (default: true)",
    },
    hashes: {
      type: "array",
      items: {
        type: "string",
      },
      description: "List of torrent hashes",
    },
  },
} as const;

export const DownloaderSettingsSchema = {
  type: "object",
  description: "Downloader configuration (supports qBittorrent)",
  properties: {
    password: {
      type: "string",
      description: "Password (qBittorrent)",
    },
    save_path: {
      type: "string",
      description: "Default save path for downloads",
    },
    type: {
      $ref: "#/components/schemas/DownloaderType",
      description: "Downloader type: qbittorrent",
    },
    url: {
      type: "string",
      description: "Downloader Web UI URL (e.g., http://localhost:8080)",
    },
    username: {
      type: "string",
      description: "Username (qBittorrent)",
    },
    webhook_url: {
      type: "string",
      description:
        "Webhook URL for torrent completion callback (e.g., http://192.168.1.100:3000)\nUsed to configure qBittorrent's autorun to call back when downloads complete",
    },
  },
} as const;

export const DownloaderTypeSchema = {
  type: "string",
  description: "Downloader type",
  enum: ["qBittorrent"],
} as const;

export const EpisodeSchema = {
  type: "object",
  description: "Episode item",
  required: ["id", "type", "name", "name_cn", "sort", "airdate"],
  properties: {
    airdate: {
      type: "string",
      description: "Air date",
    },
    ep: {
      type: ["number", "null"],
      format: "double",
      description: "Episode number",
    },
    id: {
      type: "integer",
      format: "int64",
    },
    name: {
      type: "string",
      description: "Original name",
    },
    name_cn: {
      type: "string",
      description: "Chinese name",
    },
    sort: {
      type: "number",
      format: "double",
      description: "Sort order",
    },
    type: {
      $ref: "#/components/schemas/EpisodeType",
      description: "Episode type: 0=本篇, 1=SP, 2=OP, 3=ED",
    },
  },
} as const;

export const EpisodeTypeSchema = {
  type: "string",
  description: "Episode type",
  enum: ["Main", "Special", "Opening", "Ending"],
} as const;

export const FilterSettingsSchema = {
  type: "object",
  description: "Filter configuration",
  properties: {
    global_rss_filters: {
      type: "array",
      items: {
        type: "string",
      },
      description: "Global RSS filters (regex patterns to exclude)",
    },
  },
} as const;

export const LogSchema = {
  type: "object",
  description: "System log entity",
  required: ["id", "created_at", "level", "message"],
  properties: {
    created_at: {
      type: "string",
      format: "date-time",
    },
    id: {
      type: "integer",
      format: "int64",
    },
    level: {
      $ref: "#/components/schemas/LogLevel",
      description: "日志级别: info, warning, error",
    },
    message: {
      type: "string",
      description: "日志消息",
    },
  },
} as const;

export const LogLevelSchema = {
  type: "string",
  description: "Log severity level",
  enum: ["info", "warning", "error"],
} as const;

export const PlatformSchema = {
  type: "string",
  description: "Platform type for bangumi (TV, Movie, OVA)",
  enum: ["tv", "movie", "ova"],
} as const;

export const ProxySettingsSchema = {
  type: "object",
  description: "Proxy configuration for HTTP client",
  properties: {
    password: {
      type: "string",
      description: "Proxy password (optional)",
    },
    url: {
      type: "string",
      description:
        "Proxy server URL (e.g., http://127.0.0.1:7890 or socks5://127.0.0.1:1080)",
    },
    username: {
      type: "string",
      description: "Proxy username (optional)",
    },
  },
} as const;

export const RssSchema = {
  type: "object",
  description: "RSS subscription entity",
  required: [
    "id",
    "created_at",
    "updated_at",
    "bangumi_id",
    "url",
    "enabled",
    "exclude_filters",
    "is_primary",
  ],
  properties: {
    bangumi_id: {
      type: "integer",
      format: "int64",
      description: "Foreign key to bangumi",
    },
    created_at: {
      type: "string",
      format: "date-time",
    },
    enabled: {
      type: "boolean",
      description: "Whether subscription is enabled",
    },
    exclude_filters: {
      type: "array",
      items: {
        type: "string",
      },
      description: "Regex patterns to exclude from matching",
    },
    id: {
      type: "integer",
      format: "int64",
    },
    is_primary: {
      type: "boolean",
      description:
        "Whether this is the primary RSS source (only one per bangumi)\nEpisodes from primary RSS can override those from backup RSS",
    },
    updated_at: {
      type: "string",
      format: "date-time",
    },
    url: {
      type: "string",
      description: "RSS feed URL",
    },
  },
} as const;

export const RssEntrySchema = {
  type: "object",
  description: "RSS entry for creating bangumi with subscriptions",
  required: ["url"],
  properties: {
    filters: {
      type: "array",
      items: {
        type: "string",
      },
      description: "Regex patterns to exclude from matching",
    },
    is_primary: {
      type: "boolean",
      description: "Whether this is the primary RSS source (default: false)",
    },
    url: {
      type: "string",
      description: "RSS feed URL",
    },
  },
} as const;

export const SearchResultSchema = {
  type: "object",
  required: ["id", "name"],
  properties: {
    id: {
      type: "string",
    },
    name: {
      type: "string",
    },
  },
} as const;

export const SearchSubjectsResponseSchema = {
  type: "object",
  description: "Search response from POST /v0/search/subjects",
  required: ["total", "limit", "offset", "data"],
  properties: {
    data: {
      type: "array",
      items: {
        $ref: "#/components/schemas/Subject",
      },
    },
    limit: {
      type: "integer",
      format: "int64",
    },
    offset: {
      type: "integer",
      format: "int64",
    },
    total: {
      type: "integer",
      format: "int64",
    },
  },
} as const;

export const ServerStateSchema = {
  type: "object",
  description: "Server state from sync maindata",
  properties: {
    dl_info_data: {
      type: ["integer", "null"],
      format: "int64",
      description: "Total downloaded data (bytes)",
    },
    dl_info_speed: {
      type: ["integer", "null"],
      format: "int64",
      description: "Global download speed (bytes/s)",
    },
    up_info_data: {
      type: ["integer", "null"],
      format: "int64",
      description: "Total uploaded data (bytes)",
    },
    up_info_speed: {
      type: ["integer", "null"],
      format: "int64",
      description: "Global upload speed (bytes/s)",
    },
  },
} as const;

export const SettingsSchema = {
  type: "object",
  description: "Application settings stored in TOML file",
  properties: {
    downloader: {
      $ref: "#/components/schemas/DownloaderSettings",
      description: "Downloader configuration",
    },
    filter: {
      $ref: "#/components/schemas/FilterSettings",
      description: "Filter configuration",
    },
    proxy: {
      $ref: "#/components/schemas/ProxySettings",
      description: "Proxy configuration for HTTP client",
    },
  },
} as const;

export const SourceTypeSchema = {
  type: "string",
  description: "Source type for bangumi",
  enum: ["webrip", "bdrip"],
} as const;

export const SubgroupSchema = {
  type: "object",
  required: ["id", "name", "rss_url", "episodes"],
  properties: {
    episodes: {
      type: "array",
      items: {
        $ref: "#/components/schemas/Episode",
      },
    },
    id: {
      type: "string",
    },
    name: {
      type: "string",
    },
    rss_url: {
      type: "string",
    },
  },
} as const;

export const SubjectSchema = {
  type: "object",
  description: "Subject item in search results",
  required: [
    "id",
    "name",
    "name_cn",
    "date",
    "platform",
    "images",
    "image",
    "eps",
  ],
  properties: {
    date: {
      type: "string",
    },
    eps: {
      type: "integer",
      format: "int64",
    },
    id: {
      type: "integer",
      format: "int64",
    },
    image: {
      type: "string",
    },
    images: {
      $ref: "#/components/schemas/SubjectImages",
    },
    name: {
      type: "string",
    },
    name_cn: {
      type: "string",
    },
    platform: {
      type: "string",
    },
  },
} as const;

export const SubjectImagesSchema = {
  type: "object",
  description: "Subject images from BGM.tv API",
  required: ["small", "grid", "large", "medium", "common"],
  properties: {
    common: {
      type: "string",
    },
    grid: {
      type: "string",
    },
    large: {
      type: "string",
    },
    medium: {
      type: "string",
    },
    small: {
      type: "string",
    },
  },
} as const;

export const SyncMainDataSchema = {
  type: "object",
  description:
    "Sync maindata response from qBittorrent\nUsed for incremental updates - only changed fields are included",
  required: ["rid"],
  properties: {
    full_update: {
      type: "boolean",
      description:
        "Whether this is a full update (true) or incremental (false)",
    },
    rid: {
      type: "integer",
      format: "int64",
      description:
        "Response ID for incremental updates\nPass this value in subsequent requests to get only changes",
    },
    server_state: {
      oneOf: [
        {
          type: "null",
        },
        {
          $ref: "#/components/schemas/ServerState",
          description: "Server state info",
        },
      ],
    },
    torrents: {
      type: "object",
      description:
        "Torrent data - hash -> partial torrent info\nIn incremental mode, only changed torrents are included",
      additionalProperties: {
        $ref: "#/components/schemas/SyncTorrentInfo",
      },
      propertyNames: {
        type: "string",
      },
    },
    torrents_removed: {
      type: "array",
      items: {
        type: "string",
      },
      description: "List of removed torrent hashes (incremental updates only)",
    },
  },
} as const;

export const SyncTorrentInfoSchema = {
  type: "object",
  description:
    "Partial torrent info for sync API\nAll fields are optional because incremental updates only include changed fields",
  properties: {
    added_on: {
      type: ["integer", "null"],
      format: "int64",
      description: "Time when torrent was added (Unix timestamp)",
    },
    category: {
      type: ["string", "null"],
      description: "Category",
    },
    completion_on: {
      type: ["integer", "null"],
      format: "int64",
      description: "Time when torrent completed (Unix timestamp)",
    },
    content_path: {
      type: ["string", "null"],
      description: "Content path",
    },
    dlspeed: {
      type: ["integer", "null"],
      format: "int64",
      description: "Download speed (bytes/s)",
    },
    downloaded: {
      type: ["integer", "null"],
      format: "int64",
      description: "Amount of data downloaded (bytes)",
    },
    eta: {
      type: ["integer", "null"],
      format: "int64",
      description: "Torrent ETA (seconds)",
    },
    name: {
      type: ["string", "null"],
      description: "Torrent name",
    },
    num_leechs: {
      type: ["integer", "null"],
      format: "int64",
      description: "Number of leechers",
    },
    num_seeds: {
      type: ["integer", "null"],
      format: "int64",
      description: "Number of seeds",
    },
    progress: {
      type: ["number", "null"],
      format: "double",
      description: "Torrent progress (0.0 to 1.0)",
    },
    ratio: {
      type: ["number", "null"],
      format: "double",
      description: "Share ratio",
    },
    save_path: {
      type: ["string", "null"],
      description: "Full path to the torrent's download location",
    },
    size: {
      type: ["integer", "null"],
      format: "int64",
      description: "Torrent total size (bytes)",
    },
    state: {
      type: ["string", "null"],
      description: "Torrent state",
    },
    tags: {
      type: ["string", "null"],
      description: "Tags (comma separated)",
    },
    upspeed: {
      type: ["integer", "null"],
      format: "int64",
      description: "Upload speed (bytes/s)",
    },
  },
} as const;

export const TestDownloaderRequestSchema = {
  type: "object",
  description: "Request body for testing downloader connection",
  required: ["type", "url", "username", "password"],
  properties: {
    password: {
      type: "string",
      description: "Password",
    },
    type: {
      $ref: "#/components/schemas/DownloaderType",
      description: 'Downloader type (e.g., "qbittorrent")',
    },
    url: {
      type: "string",
      description: "Downloader Web UI URL",
    },
    username: {
      type: "string",
      description: "Username",
    },
  },
} as const;

export const TestProxyRequestSchema = {
  type: "object",
  description: "Request body for testing proxy connection",
  required: ["url"],
  properties: {
    password: {
      type: ["string", "null"],
      description: "Proxy password (optional)",
    },
    url: {
      type: "string",
      description: "Proxy server URL (e.g., http://127.0.0.1:7890)",
    },
    username: {
      type: ["string", "null"],
      description: "Proxy username (optional)",
    },
  },
} as const;

export const TorrentInfoSchema = {
  type: "object",
  description: "Torrent information from qBittorrent",
  required: [
    "hash",
    "name",
    "state",
    "progress",
    "save_path",
    "size",
    "downloaded",
    "eta",
  ],
  properties: {
    downloaded: {
      type: "integer",
      format: "int64",
      description: "Amount of data downloaded (bytes)",
    },
    eta: {
      type: "integer",
      format: "int64",
      description: "Torrent ETA (seconds)",
    },
    hash: {
      type: "string",
      description: "Torrent hash",
    },
    name: {
      type: "string",
      description: "Torrent name",
    },
    progress: {
      type: "number",
      format: "double",
      description: "Torrent progress (0.0 to 1.0)",
    },
    save_path: {
      type: "string",
      description: "Full path to the torrent's download location",
    },
    size: {
      type: "integer",
      format: "int64",
      description: "Torrent total size (bytes)",
    },
    state: {
      type: "string",
      description:
        "Torrent state (downloading, uploading, pausedDL, pausedUP, stalledDL, stalledUP, checkingDL, checkingUP, completed, etc.)",
    },
  },
} as const;

export const TorrentSearchResultSchema = {
  type: "object",
  required: ["title", "torrent_url", "info_hash", "source"],
  properties: {
    info_hash: {
      type: "string",
    },
    source: {
      $ref: "#/components/schemas/TorrentSource",
    },
    title: {
      type: "string",
    },
    torrent_url: {
      type: "string",
    },
  },
} as const;

export const TorrentSourceSchema = {
  type: "string",
  enum: ["mikan", "nyaa"],
} as const;

export const TvShowSchema = {
  type: "object",
  required: [
    "id",
    "name",
    "original_name",
    "overview",
    "vote_average",
    "vote_count",
    "popularity",
    "genre_ids",
    "origin_country",
    "original_language",
  ],
  properties: {
    backdrop_path: {
      type: ["string", "null"],
    },
    first_air_date: {
      type: ["string", "null"],
    },
    genre_ids: {
      type: "array",
      items: {
        type: "integer",
        format: "int64",
      },
    },
    id: {
      type: "integer",
      format: "int64",
    },
    name: {
      type: "string",
    },
    origin_country: {
      type: "array",
      items: {
        type: "string",
      },
    },
    original_language: {
      type: "string",
    },
    original_name: {
      type: "string",
    },
    overview: {
      type: "string",
    },
    popularity: {
      type: "number",
      format: "double",
    },
    poster_path: {
      type: ["string", "null"],
    },
    vote_average: {
      type: "number",
      format: "double",
    },
    vote_count: {
      type: "integer",
      format: "int64",
    },
  },
} as const;

export const UpdateBangumiRequestSchema = {
  type: "object",
  description: "Request body for updating a bangumi with RSS entries",
  properties: {
    air_date: {
      type: ["string", "null"],
      description: "First air date (None = unchanged, Some = new value)",
    },
    air_week: {
      type: ["integer", "null"],
      format: "int32",
      description:
        "Day of week when new episodes air (None = unchanged, Some = new value)",
    },
    auto_download: {
      type: ["boolean", "null"],
      description: "Auto download new episodes",
    },
    episode_offset: {
      type: ["integer", "null"],
      format: "int32",
      description: "Episode offset",
    },
    rss_entries: {
      type: ["array", "null"],
      items: {
        $ref: "#/components/schemas/RssEntry",
      },
      description: "RSS entries to sync (replaces all existing entries)",
    },
    save_path: {
      type: ["string", "null"],
      description: "Save path (None = unchanged, Some = new value)",
    },
  },
} as const;

export const UpdateDownloaderSettingsSchema = {
  type: "object",
  description: "Request body for updating downloader settings",
  properties: {
    password: {
      type: ["string", "null"],
      description: "Password (send null to clear)",
    },
    save_path: {
      type: ["string", "null"],
      description: "Default save path for downloads (send null to clear)",
    },
    type: {
      oneOf: [
        {
          type: "null",
        },
        {
          $ref: "#/components/schemas/DownloaderType",
          description: "Downloader type: qbittorrent",
        },
      ],
    },
    url: {
      type: ["string", "null"],
      description: "Downloader Web UI URL (send null to clear)",
    },
    username: {
      type: ["string", "null"],
      description: "Username (send null to clear)",
    },
    webhook_url: {
      type: ["string", "null"],
      description:
        "Webhook URL for torrent completion callback (send null to clear)",
    },
  },
} as const;

export const UpdateFilterSettingsSchema = {
  type: "object",
  description: "Request body for updating filter settings",
  properties: {
    global_rss_filters: {
      type: ["array", "null"],
      items: {
        type: "string",
      },
      description: "Global RSS filters (replaces entire array if provided)",
    },
  },
} as const;

export const UpdateProxySettingsSchema = {
  type: "object",
  description: "Request body for updating proxy settings",
  properties: {
    password: {
      type: ["string", "null"],
      description: "Password (send null to clear)",
    },
    url: {
      type: ["string", "null"],
      description: "Proxy server URL (send null to clear)",
    },
    username: {
      type: ["string", "null"],
      description: "Username (send null to clear)",
    },
  },
} as const;

export const UpdateSettingsSchema = {
  type: "object",
  description:
    "Request body for updating settings.\nAll fields are optional - only provided fields will be updated.",
  properties: {
    downloader: {
      oneOf: [
        {
          type: "null",
        },
        {
          $ref: "#/components/schemas/UpdateDownloaderSettings",
          description: "Downloader configuration updates",
        },
      ],
    },
    filter: {
      oneOf: [
        {
          type: "null",
        },
        {
          $ref: "#/components/schemas/UpdateFilterSettings",
          description: "Filter configuration updates",
        },
      ],
    },
    proxy: {
      oneOf: [
        {
          type: "null",
        },
        {
          $ref: "#/components/schemas/UpdateProxySettings",
          description: "Proxy configuration updates",
        },
      ],
    },
  },
} as const;
