// This file is auto-generated by @hey-api/openapi-ts

export const BangumiSchema = {
  type: "object",
  description:
    "Bangumi (anime) subscription entity\nStores user's subscription state and download configuration",
  required: [
    "id",
    "created_at",
    "updated_at",
    "metadata_id",
    "episode_offset",
    "current_episode",
    "auto_complete",
    "save_path",
    "source_type",
  ],
  properties: {
    auto_complete: {
      type: "boolean",
      description: "Only download first matching episode per RSS check",
    },
    created_at: {
      type: "string",
      format: "date-time",
    },
    current_episode: {
      type: "integer",
      format: "int32",
      description: "Current downloaded episode",
    },
    episode_offset: {
      type: "integer",
      format: "int32",
      description: "Episode offset",
    },
    id: {
      type: "integer",
      format: "int64",
    },
    metadata_id: {
      type: "integer",
      format: "int64",
      description: "Reference to metadata (foreign key)",
    },
    save_path: {
      type: "string",
      description: "Save path (required)",
    },
    source_type: {
      $ref: "#/components/schemas/SourceType",
      description: "Source type: webrip or bdrip",
    },
    updated_at: {
      type: "string",
      format: "date-time",
    },
  },
} as const;

export const BangumiDetailSchema = {
  type: "object",
  required: ["subgroups"],
  properties: {
    bgmtv_id: {
      type: ["integer", "null"],
      format: "int64",
    },
    subgroups: {
      type: "array",
      items: {
        $ref: "#/components/schemas/Subgroup",
      },
    },
  },
} as const;

export const BangumiWithMetadataSchema = {
  allOf: [
    {
      $ref: "#/components/schemas/Bangumi",
    },
    {
      type: "object",
      required: ["metadata"],
      properties: {
        metadata: {
          $ref: "#/components/schemas/Metadata",
          description: "Associated metadata",
        },
      },
    },
  ],
  description: "Bangumi with its associated metadata",
} as const;

export const BangumiWithRssSchema = {
  allOf: [
    {
      $ref: "#/components/schemas/Bangumi",
    },
    {
      type: "object",
      required: ["metadata", "rss_entries"],
      properties: {
        metadata: {
          $ref: "#/components/schemas/Metadata",
          description: "Associated metadata",
        },
        rss_entries: {
          type: "array",
          items: {
            $ref: "#/components/schemas/Rss",
          },
          description: "RSS subscriptions for this bangumi",
        },
      },
    },
  ],
  description: "Bangumi with metadata and RSS subscriptions",
} as const;

export const CalendarDaySchema = {
  type: "object",
  description: "Calendar day with weekday info and items",
  required: ["weekday", "items"],
  properties: {
    items: {
      type: "array",
      items: {
        $ref: "#/components/schemas/CalendarSubject",
      },
    },
    weekday: {
      $ref: "#/components/schemas/Weekday",
    },
  },
} as const;

export const CalendarSubjectSchema = {
  type: "object",
  description: "Subject item in calendar results",
  required: ["title_chinese", "air_week", "platform", "total_episodes"],
  properties: {
    air_date: {
      type: ["string", "null"],
      description: "First air date (YYYY-MM-DD)",
    },
    air_week: {
      type: "integer",
      format: "int32",
      description: "Day of week (0=Sunday, 1-6=Mon-Sat)",
    },
    bgmtv_id: {
      type: ["integer", "null"],
      format: "int64",
      description: "BGM.tv subject ID",
    },
    mikan_id: {
      type: ["string", "null"],
      description: "Mikan bangumi ID",
    },
    platform: {
      $ref: "#/components/schemas/Platform",
      description: "Platform type (tv, movie, ova)",
    },
    poster_url: {
      type: ["string", "null"],
      description: "Poster image URL",
    },
    title_chinese: {
      type: "string",
      description: "Chinese title",
    },
    title_japanese: {
      type: ["string", "null"],
      description: "Japanese title",
    },
    total_episodes: {
      type: "integer",
      format: "int32",
      description: "Total episodes",
    },
  },
} as const;

export const CreateBangumiSchema = {
  type: "object",
  description: "Request body for creating a new bangumi",
  properties: {
    auto_complete: {
      type: "boolean",
      description: "Only download first matching episode per RSS check",
    },
    episode_offset: {
      type: "integer",
      format: "int32",
      description: "Episode offset",
    },
    metadata: {
      oneOf: [
        {
          type: "null",
        },
        {
          $ref: "#/components/schemas/CreateMetadata",
          description: "Inline metadata creation (if not using existing)",
        },
      ],
    },
    metadata_id: {
      type: ["integer", "null"],
      format: "int64",
      description: "Metadata ID (if using existing metadata)",
    },
    rss_entries: {
      type: "array",
      items: {
        $ref: "#/components/schemas/RssEntry",
      },
      description: "RSS subscriptions to create with this bangumi",
    },
    source_type: {
      $ref: "#/components/schemas/SourceType",
      description: "Source type",
    },
  },
} as const;

export const CreateMetadataSchema = {
  type: "object",
  description: "Request body for creating new metadata",
  required: ["title_chinese", "year", "air_week"],
  properties: {
    air_date: {
      type: ["string", "null"],
      description: "First air date (YYYY-MM-DD format)",
    },
    air_week: {
      type: "integer",
      format: "int32",
      description: "Day of week when new episodes air (0=Sunday ~ 6=Saturday)",
    },
    bgmtv_id: {
      type: ["integer", "null"],
      format: "int64",
      description: "BGM.tv subject ID",
    },
    finished: {
      type: "boolean",
      description: "Whether the anime has finished airing",
    },
    mikan_id: {
      type: ["string", "null"],
      description: "Mikan bangumi ID",
    },
    platform: {
      $ref: "#/components/schemas/Platform",
      description: "Platform type (TV, Movie, OVA)",
    },
    poster_url: {
      type: ["string", "null"],
      description: "Poster image URL",
    },
    season: {
      type: "integer",
      format: "int32",
      description: "Season number (default: 1)",
    },
    title_chinese: {
      type: "string",
      description: "Chinese title (required)",
    },
    title_japanese: {
      type: ["string", "null"],
      description: "Japanese original name",
    },
    tmdb_id: {
      type: ["integer", "null"],
      format: "int64",
      description: "TMDB ID",
    },
    total_episodes: {
      type: "integer",
      format: "int32",
      description: "Total episodes",
    },
    year: {
      type: "integer",
      format: "int32",
      description: "Year (required)",
    },
  },
} as const;

export const DeleteTorrentsRequestSchema = {
  type: "object",
  description: "Request to delete torrents",
  required: ["hashes"],
  properties: {
    delete_files: {
      type: "boolean",
      description: "Whether to delete downloaded files (default: true)",
    },
    hashes: {
      type: "array",
      items: {
        type: "string",
      },
      description: "List of torrent hashes",
    },
  },
} as const;

export const DownloaderConfigsSchema = {
  type: "object",
  description: "Per-downloader configurations",
  properties: {
    qbittorrent: {
      $ref: "#/components/schemas/QBittorrentConfig",
      description: "qBittorrent configuration",
    },
    transmission: {
      $ref: "#/components/schemas/TransmissionConfig",
      description: "Transmission configuration",
    },
  },
} as const;

export const DownloaderSettingsSchema = {
  type: "object",
  description: "Downloader configuration with per-type configs",
  properties: {
    configs: {
      $ref: "#/components/schemas/DownloaderConfigs",
      description: "Per-downloader configurations",
    },
    save_path: {
      type: "string",
      description:
        "Default save path for downloads (shared across all downloaders)",
    },
    type: {
      $ref: "#/components/schemas/DownloaderType",
      description: "Currently active downloader type",
    },
  },
} as const;

export const DownloaderTypeSchema = {
  type: "string",
  description: "Downloader type",
  enum: ["qBittorrent", "Transmission"],
} as const;

export const EpisodeSchema = {
  type: "object",
  description: "Episode item",
  required: ["id", "type", "name", "name_cn", "sort", "airdate"],
  properties: {
    airdate: {
      type: "string",
      description: "Air date",
    },
    ep: {
      type: ["number", "null"],
      format: "double",
      description: "Episode number",
    },
    id: {
      type: "integer",
      format: "int64",
    },
    name: {
      type: "string",
      description: "Original name",
    },
    name_cn: {
      type: "string",
      description: "Chinese name",
    },
    sort: {
      type: "number",
      format: "double",
      description: "Sort order",
    },
    type: {
      $ref: "#/components/schemas/EpisodeType",
      description: "Episode type: 0=本篇, 1=SP, 2=OP, 3=ED",
    },
  },
} as const;

export const EpisodeTypeSchema = {
  type: "string",
  description: "Episode type",
  enum: ["Main", "Special", "Opening", "Ending"],
} as const;

export const FilterSettingsSchema = {
  type: "object",
  description: "Filter configuration",
  properties: {
    global_rss_filters: {
      type: "array",
      items: {
        type: "string",
      },
      description: "Global RSS filters (regex patterns to exclude)",
    },
  },
} as const;

export const LogSchema = {
  type: "object",
  description: "System log entity",
  required: ["id", "created_at", "level", "message"],
  properties: {
    created_at: {
      type: "string",
      format: "date-time",
    },
    id: {
      type: "integer",
      format: "int64",
    },
    level: {
      $ref: "#/components/schemas/LogLevel",
      description: "日志级别: info, warning, error",
    },
    message: {
      type: "string",
      description: "日志消息",
    },
  },
} as const;

export const LogLevelSchema = {
  type: "string",
  description: "Log severity level",
  enum: ["info", "warning", "error"],
} as const;

export const MetadataSchema = {
  type: "object",
  description:
    "Metadata entity for anime information\nUnified metadata center caching data from BGM.tv, TMDB, and Mikan",
  required: [
    "id",
    "created_at",
    "updated_at",
    "title_chinese",
    "season",
    "year",
    "platform",
    "total_episodes",
    "air_week",
    "finished",
  ],
  properties: {
    air_date: {
      type: ["string", "null"],
      description: "First air date (YYYY-MM-DD format)",
    },
    air_week: {
      type: "integer",
      format: "int32",
      description: "Day of week when new episodes air (0=Sunday ~ 6=Saturday)",
    },
    bgmtv_id: {
      type: ["integer", "null"],
      format: "int64",
      description: "BGM.tv subject ID",
    },
    created_at: {
      type: "string",
      format: "date-time",
    },
    finished: {
      type: "boolean",
      description: "Whether the anime has finished airing",
    },
    id: {
      type: "integer",
      format: "int64",
    },
    mikan_id: {
      type: ["string", "null"],
      description: "Mikan bangumi ID",
    },
    platform: {
      $ref: "#/components/schemas/Platform",
      description: "Platform type (TV, Movie, OVA)",
    },
    poster_url: {
      type: ["string", "null"],
      description: "Poster image URL",
    },
    season: {
      type: "integer",
      format: "int32",
      description: "Season number",
    },
    title_chinese: {
      type: "string",
      description: "Chinese title (primary display)",
    },
    title_japanese: {
      type: ["string", "null"],
      description: "Japanese original name",
    },
    tmdb_id: {
      type: ["integer", "null"],
      format: "int64",
      description: "TMDB ID",
    },
    total_episodes: {
      type: "integer",
      format: "int32",
      description: "Total episodes (0=unknown)",
    },
    updated_at: {
      type: "string",
      format: "date-time",
    },
    year: {
      type: "integer",
      format: "int32",
      description: "Year",
    },
  },
} as const;

export const NotificationSettingsSchema = {
  type: "object",
  description: "Notification configuration",
  properties: {
    enabled: {
      type: "boolean",
      description: "Global enable/disable for notifications",
    },
    telegram: {
      $ref: "#/components/schemas/TelegramConfig",
      description: "Telegram configuration",
    },
  },
} as const;

export const PlatformSchema = {
  type: "string",
  description: "Platform type for bangumi (TV, Movie, OVA)",
  enum: ["tv", "movie", "ova"],
} as const;

export const PrioritySettingsSchema = {
  type: "object",
  description: "Priority configuration for torrent selection and washing",
  properties: {
    subtitle_groups: {
      type: "array",
      items: {
        type: "string",
      },
      description:
        "Subtitle groups in priority order (first = highest priority)",
    },
    subtitle_language_sets: {
      type: "array",
      items: {
        $ref: "#/components/schemas/SubtitleLanguageSet",
      },
      description:
        "Subtitle language combinations in priority order (first = highest priority)\nEach entry is a set of languages that must exactly match\nExample: [[CHS, JPN], [CHS, CHT, JPN], [CHT]]",
    },
  },
} as const;

export const ProxySettingsSchema = {
  type: "object",
  description: "Proxy configuration for HTTP client",
  properties: {
    password: {
      type: "string",
      description: "Proxy password (optional)",
    },
    url: {
      type: "string",
      description:
        "Proxy server URL (e.g., http://127.0.0.1:7890 or socks5://127.0.0.1:1080)",
    },
    username: {
      type: "string",
      description: "Proxy username (optional)",
    },
  },
} as const;

export const QBittorrentConfigSchema = {
  type: "object",
  description: "qBittorrent-specific configuration",
  properties: {
    password: {
      type: "string",
      description: "Password (required)",
    },
    url: {
      type: "string",
      description: "Web UI URL (e.g., http://localhost:8080)",
    },
    username: {
      type: "string",
      description: "Username (required)",
    },
  },
} as const;

export const RssSchema = {
  type: "object",
  description: "RSS subscription entity",
  required: [
    "id",
    "created_at",
    "updated_at",
    "bangumi_id",
    "title",
    "url",
    "enabled",
    "exclude_filters",
    "include_filters",
  ],
  properties: {
    bangumi_id: {
      type: "integer",
      format: "int64",
      description: "Foreign key to bangumi",
    },
    created_at: {
      type: "string",
      format: "date-time",
    },
    enabled: {
      type: "boolean",
      description: "Whether subscription is enabled",
    },
    exclude_filters: {
      type: "array",
      items: {
        type: "string",
      },
      description: "Regex patterns to exclude from matching",
    },
    group: {
      type: ["string", "null"],
      description: "Optional subtitle group name",
    },
    id: {
      type: "integer",
      format: "int64",
    },
    include_filters: {
      type: "array",
      items: {
        type: "string",
      },
      description: "Regex patterns to include in matching",
    },
    title: {
      type: "string",
      description: "RSS subscription title: [group] {bangumi} S{season}",
    },
    updated_at: {
      type: "string",
      format: "date-time",
    },
    url: {
      type: "string",
      description: "RSS feed URL",
    },
  },
} as const;

export const RssEntrySchema = {
  type: "object",
  description: "RSS entry for creating bangumi with subscriptions",
  required: ["url"],
  properties: {
    filters: {
      type: "array",
      items: {
        type: "string",
      },
      description: "Regex patterns to exclude from matching",
    },
    group: {
      type: ["string", "null"],
      description: "Optional subtitle group name",
    },
    include_filters: {
      type: "array",
      items: {
        type: "string",
      },
      description: "Regex patterns to include in matching",
    },
    url: {
      type: "string",
      description: "RSS feed URL",
    },
  },
} as const;

export const SearchResultSchema = {
  type: "object",
  required: ["id", "name"],
  properties: {
    id: {
      type: "string",
    },
    name: {
      type: "string",
    },
  },
} as const;

export const SearchSubjectsResponseSchema = {
  type: "object",
  description: "Search response from POST /v0/search/subjects",
  required: ["total", "limit", "offset", "data"],
  properties: {
    data: {
      type: "array",
      items: {
        $ref: "#/components/schemas/Subject",
      },
    },
    limit: {
      type: "integer",
      format: "int64",
    },
    offset: {
      type: "integer",
      format: "int64",
    },
    total: {
      type: "integer",
      format: "int64",
    },
  },
} as const;

export const SeasonSchema = {
  type: "string",
  enum: ["winter", "spring", "summer", "fall"],
} as const;

export const SettingsSchema = {
  type: "object",
  description: "Application settings stored in TOML file",
  properties: {
    downloader: {
      $ref: "#/components/schemas/DownloaderSettings",
      description: "Downloader configuration",
    },
    filter: {
      $ref: "#/components/schemas/FilterSettings",
      description: "Filter configuration",
    },
    notification: {
      $ref: "#/components/schemas/NotificationSettings",
      description: "Notification configuration",
    },
    priority: {
      $ref: "#/components/schemas/PrioritySettings",
      description: "Priority configuration for torrent selection and washing",
    },
    proxy: {
      $ref: "#/components/schemas/ProxySettings",
      description: "Proxy configuration for HTTP client",
    },
  },
} as const;

export const SourceTypeSchema = {
  type: "string",
  description: "Source type for bangumi",
  enum: ["webrip", "bdrip"],
} as const;

export const SubTypeSchema = {
  type: "string",
  description: "字幕类型枚举",
  enum: ["CHS", "CHT", "JPN", "ENG", "UNKNOWN"],
} as const;

export const SubgroupSchema = {
  type: "object",
  required: ["id", "name", "rss_url", "episodes"],
  properties: {
    episodes: {
      type: "array",
      items: {
        $ref: "#/components/schemas/Episode",
      },
    },
    id: {
      type: "string",
    },
    name: {
      type: "string",
    },
    rss_url: {
      type: "string",
    },
  },
} as const;

export const SubjectSchema = {
  type: "object",
  description: "Subject item in search results",
  required: [
    "id",
    "name",
    "name_cn",
    "date",
    "platform",
    "images",
    "image",
    "eps",
  ],
  properties: {
    date: {
      type: "string",
    },
    eps: {
      type: "integer",
      format: "int64",
    },
    id: {
      type: "integer",
      format: "int64",
    },
    image: {
      type: "string",
    },
    images: {
      $ref: "#/components/schemas/SubjectImages",
    },
    name: {
      type: "string",
    },
    name_cn: {
      type: "string",
    },
    platform: {
      type: "string",
    },
  },
} as const;

export const SubjectImagesSchema = {
  type: "object",
  description: "Subject images from BGM.tv API",
  required: ["small", "grid", "large", "medium", "common"],
  properties: {
    common: {
      type: "string",
    },
    grid: {
      type: "string",
    },
    large: {
      type: "string",
    },
    medium: {
      type: "string",
    },
    small: {
      type: "string",
    },
  },
} as const;

export const SubjectTypeSchema = {
  type: "string",
  description: "BGM.tv subject type",
  enum: ["Book", "Anime", "Music", "Game", "Real"],
} as const;

export const SubtitleLanguageSetSchema = {
  type: "object",
  description:
    "A normalized set of subtitle languages for exact matching.\n\nLanguages are automatically sorted and deduplicated on creation,\nensuring that `[Chs, Jpn]` and `[Jpn, Chs]` are treated as equal.",
  required: ["languages"],
  properties: {
    languages: {
      type: "array",
      items: {
        $ref: "#/components/schemas/SubType",
      },
      description: "Sorted and deduplicated language list",
    },
  },
} as const;

export const TaskSchema = {
  type: "object",
  description:
    "Unified download task representation.\n\nThis model represents a download task across different downloaders,\nnormalizing fields into a common structure.",
  required: [
    "id",
    "name",
    "status",
    "progress",
    "save_path",
    "total_size",
    "downloaded",
    "eta",
    "tags",
  ],
  properties: {
    category: {
      type: ["string", "null"],
      description: "Category (optional, some downloaders support this)",
    },
    downloaded: {
      type: "integer",
      format: "int64",
      description: "Downloaded bytes",
    },
    eta: {
      type: "integer",
      format: "int64",
      description: "Estimated time to completion (seconds, -1 if unknown)",
    },
    id: {
      type: "string",
      description: "Unique identifier (hash for BitTorrent, ID for HTTP)",
    },
    name: {
      type: "string",
      description: "Task name",
    },
    progress: {
      type: "number",
      format: "double",
      description: "Download progress (0.0 to 1.0)",
    },
    save_path: {
      type: "string",
      description: "Save path / download directory",
    },
    status: {
      $ref: "#/components/schemas/TaskStatus",
      description: "Current status",
    },
    tags: {
      type: "string",
      description: "Tags (comma-separated string for consistency)",
    },
    total_size: {
      type: "integer",
      format: "int64",
      description: "Total size in bytes",
    },
  },
} as const;

export const TaskStatusSchema = {
  type: "string",
  description:
    "Download task status.\n\nNormalized across different downloader implementations.",
  enum: [
    "queued",
    "downloading",
    "paused",
    "seeding",
    "completed",
    "stalled",
    "checking",
    "error",
    "unknown",
  ],
} as const;

export const TelegramConfigSchema = {
  type: "object",
  description: "Telegram notification configuration",
  properties: {
    bot_token: {
      type: "string",
      description: "Telegram Bot API token",
    },
    chat_id: {
      type: "string",
      description: "Telegram chat ID to send notifications to",
    },
    enabled: {
      type: "boolean",
      description: "Enable Telegram notifications",
    },
  },
} as const;

export const TestDownloaderRequestSchema = {
  type: "object",
  description: "Request body for testing downloader connection",
  required: ["type", "url", "username", "password"],
  properties: {
    password: {
      type: "string",
      description: "Password",
    },
    type: {
      $ref: "#/components/schemas/DownloaderType",
      description: 'Downloader type (e.g., "qbittorrent")',
    },
    url: {
      type: "string",
      description: "Downloader Web UI URL",
    },
    username: {
      type: "string",
      description: "Username",
    },
  },
} as const;

export const TestNotificationRequestSchema = {
  type: "object",
  description: "Request body for testing Telegram notification",
  required: ["bot_token", "chat_id"],
  properties: {
    bot_token: {
      type: "string",
      description: "Telegram Bot API token",
    },
    chat_id: {
      type: "string",
      description: "Telegram chat ID",
    },
  },
} as const;

export const TestProxyRequestSchema = {
  type: "object",
  description: "Request body for testing proxy connection",
  required: ["url"],
  properties: {
    password: {
      type: ["string", "null"],
      description: "Proxy password (optional)",
    },
    url: {
      type: "string",
      description: "Proxy server URL (e.g., http://127.0.0.1:7890)",
    },
    username: {
      type: ["string", "null"],
      description: "Proxy username (optional)",
    },
  },
} as const;

export const TorrentSearchResultSchema = {
  type: "object",
  required: ["title", "torrent_url", "info_hash", "source"],
  properties: {
    info_hash: {
      type: "string",
    },
    source: {
      $ref: "#/components/schemas/TorrentSource",
    },
    title: {
      type: "string",
    },
    torrent_url: {
      type: "string",
    },
  },
} as const;

export const TorrentSourceSchema = {
  type: "string",
  enum: ["mikan", "nyaa"],
} as const;

export const TransmissionConfigSchema = {
  type: "object",
  description: "Transmission-specific configuration",
  properties: {
    password: {
      type: "string",
      description: "Password (optional)",
    },
    url: {
      type: "string",
      description: "RPC URL (e.g., http://localhost:9091/transmission/rpc)",
    },
    username: {
      type: "string",
      description: "Username (optional)",
    },
  },
} as const;

export const TvShowSchema = {
  type: "object",
  required: [
    "id",
    "name",
    "original_name",
    "overview",
    "vote_average",
    "vote_count",
    "popularity",
    "genre_ids",
    "origin_country",
    "original_language",
  ],
  properties: {
    backdrop_path: {
      type: ["string", "null"],
    },
    first_air_date: {
      type: ["string", "null"],
    },
    genre_ids: {
      type: "array",
      items: {
        type: "integer",
        format: "int64",
      },
    },
    id: {
      type: "integer",
      format: "int64",
    },
    name: {
      type: "string",
    },
    origin_country: {
      type: "array",
      items: {
        type: "string",
      },
    },
    original_language: {
      type: "string",
    },
    original_name: {
      type: "string",
    },
    overview: {
      type: "string",
    },
    popularity: {
      type: "number",
      format: "double",
    },
    poster_path: {
      type: ["string", "null"],
    },
    vote_average: {
      type: "number",
      format: "double",
    },
    vote_count: {
      type: "integer",
      format: "int64",
    },
  },
} as const;

export const UpdateBangumiRequestSchema = {
  type: "object",
  description: "Request body for updating a bangumi with RSS entries",
  properties: {
    auto_complete: {
      type: ["boolean", "null"],
      description: "Only download first matching episode per RSS check",
    },
    episode_offset: {
      type: ["integer", "null"],
      format: "int32",
      description: "Episode offset",
    },
    rss_entries: {
      type: ["array", "null"],
      items: {
        $ref: "#/components/schemas/RssEntry",
      },
      description: "RSS entries to sync (replaces all existing entries)",
    },
  },
} as const;

export const UpdateDownloaderSettingsSchema = {
  type: "object",
  description: "Request body for updating downloader settings",
  properties: {
    qbittorrent: {
      oneOf: [
        {
          type: "null",
        },
        {
          $ref: "#/components/schemas/UpdateQBittorrentConfig",
          description: "Update qBittorrent config",
        },
      ],
    },
    save_path: {
      type: ["string", "null"],
      description: "Update shared save path (send null to clear)",
    },
    transmission: {
      oneOf: [
        {
          type: "null",
        },
        {
          $ref: "#/components/schemas/UpdateTransmissionConfig",
          description: "Update Transmission config",
        },
      ],
    },
    type: {
      oneOf: [
        {
          type: "null",
        },
        {
          $ref: "#/components/schemas/DownloaderType",
          description: "Switch active downloader type",
        },
      ],
    },
  },
} as const;

export const UpdateFilterSettingsSchema = {
  type: "object",
  description: "Request body for updating filter settings",
  properties: {
    global_rss_filters: {
      type: ["array", "null"],
      items: {
        type: "string",
      },
      description: "Global RSS filters (replaces entire array if provided)",
    },
  },
} as const;

export const UpdateMetadataSchema = {
  type: "object",
  description:
    "Request body for updating metadata\nFor Clearable fields: null means clear the value, value means set new value, absent means unchanged",
  properties: {
    air_date: {
      type: ["string", "null"],
      description: "First air date in YYYY-MM-DD format (null to clear)",
    },
    air_week: {
      type: ["integer", "null"],
      format: "int32",
      description: "Day of week when new episodes air (0=Sunday ~ 6=Saturday)",
    },
    bgmtv_id: {
      type: ["integer", "null"],
      format: "int64",
      description: "BGM.tv subject ID (null to clear)",
    },
    finished: {
      type: ["boolean", "null"],
      description: "Whether the anime has finished airing",
    },
    mikan_id: {
      type: ["string", "null"],
      description: "Mikan bangumi ID (null to clear)",
    },
    platform: {
      oneOf: [
        {
          type: "null",
        },
        {
          $ref: "#/components/schemas/Platform",
          description: "Platform type (TV, Movie, OVA)",
        },
      ],
    },
    poster_url: {
      type: ["string", "null"],
      description: "Poster image URL (null to clear)",
    },
    season: {
      type: ["integer", "null"],
      format: "int32",
      description: "Season number",
    },
    title_chinese: {
      type: ["string", "null"],
      description: "Chinese title",
    },
    title_japanese: {
      type: ["string", "null"],
      description: "Japanese original name (null to clear)",
    },
    tmdb_id: {
      type: ["integer", "null"],
      format: "int64",
      description: "TMDB ID (null to clear)",
    },
    total_episodes: {
      type: ["integer", "null"],
      format: "int32",
      description: "Total episodes",
    },
    year: {
      type: ["integer", "null"],
      format: "int32",
      description: "Year",
    },
  },
} as const;

export const UpdateNotificationSettingsSchema = {
  type: "object",
  description: "Request body for updating notification settings",
  properties: {
    enabled: {
      type: ["boolean", "null"],
      description: "Enable/disable notifications globally",
    },
    telegram: {
      oneOf: [
        {
          type: "null",
        },
        {
          $ref: "#/components/schemas/UpdateTelegramConfig",
          description: "Telegram configuration updates",
        },
      ],
    },
  },
} as const;

export const UpdatePrioritySettingsSchema = {
  type: "object",
  description: "Request body for updating priority settings",
  properties: {
    subtitle_groups: {
      type: ["array", "null"],
      items: {
        type: "string",
      },
      description:
        "Subtitle groups in priority order (replaces entire array if provided)",
    },
    subtitle_language_sets: {
      type: ["array", "null"],
      items: {
        $ref: "#/components/schemas/SubtitleLanguageSet",
      },
      description:
        "Subtitle language combinations in priority order (replaces entire array if provided)\nEach entry is a set of languages that must exactly match",
    },
  },
} as const;

export const UpdateProxySettingsSchema = {
  type: "object",
  description: "Request body for updating proxy settings",
  properties: {
    password: {
      type: ["string", "null"],
      description: "Password (send null to clear)",
    },
    url: {
      type: ["string", "null"],
      description: "Proxy server URL (send null to clear)",
    },
    username: {
      type: ["string", "null"],
      description: "Username (send null to clear)",
    },
  },
} as const;

export const UpdateQBittorrentConfigSchema = {
  type: "object",
  description: "Request body for updating qBittorrent settings",
  properties: {
    password: {
      type: ["string", "null"],
      description: "Password (send null to clear)",
    },
    url: {
      type: ["string", "null"],
      description: "Web UI URL (send null to clear)",
    },
    username: {
      type: ["string", "null"],
      description: "Username (send null to clear)",
    },
  },
} as const;

export const UpdateSettingsSchema = {
  type: "object",
  description:
    "Request body for updating settings.\nAll fields are optional - only provided fields will be updated.",
  properties: {
    downloader: {
      oneOf: [
        {
          type: "null",
        },
        {
          $ref: "#/components/schemas/UpdateDownloaderSettings",
          description: "Downloader configuration updates",
        },
      ],
    },
    filter: {
      oneOf: [
        {
          type: "null",
        },
        {
          $ref: "#/components/schemas/UpdateFilterSettings",
          description: "Filter configuration updates",
        },
      ],
    },
    notification: {
      oneOf: [
        {
          type: "null",
        },
        {
          $ref: "#/components/schemas/UpdateNotificationSettings",
          description: "Notification configuration updates",
        },
      ],
    },
    priority: {
      oneOf: [
        {
          type: "null",
        },
        {
          $ref: "#/components/schemas/UpdatePrioritySettings",
          description: "Priority configuration updates",
        },
      ],
    },
    proxy: {
      oneOf: [
        {
          type: "null",
        },
        {
          $ref: "#/components/schemas/UpdateProxySettings",
          description: "Proxy configuration updates",
        },
      ],
    },
  },
} as const;

export const UpdateTelegramConfigSchema = {
  type: "object",
  description: "Request body for updating Telegram settings",
  properties: {
    bot_token: {
      type: ["string", "null"],
      description: "Bot token (send null to clear)",
    },
    chat_id: {
      type: ["string", "null"],
      description: "Chat ID (send null to clear)",
    },
    enabled: {
      type: ["boolean", "null"],
      description: "Enable Telegram notifications",
    },
  },
} as const;

export const UpdateTransmissionConfigSchema = {
  type: "object",
  description: "Request body for updating Transmission settings",
  properties: {
    password: {
      type: ["string", "null"],
      description: "Password (send null to clear)",
    },
    url: {
      type: ["string", "null"],
      description: "RPC URL (send null to clear)",
    },
    username: {
      type: ["string", "null"],
      description: "Username (send null to clear)",
    },
  },
} as const;

export const WeekdaySchema = {
  type: "object",
  description: "Weekday info",
  required: ["id", "en", "cn", "ja"],
  properties: {
    cn: {
      type: "string",
      description: "Chinese name",
    },
    en: {
      type: "string",
      description: "English name",
    },
    id: {
      type: "integer",
      format: "int32",
      description: "Weekday ID (1=Mon, 7=Sun)",
    },
    ja: {
      type: "string",
      description: "Japanese name",
    },
  },
} as const;
